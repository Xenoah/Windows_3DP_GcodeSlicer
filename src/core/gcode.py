"""
G-code generator.

Converts sliced layers into Marlin/Klipper compatible G-code.
"""

import math
import io
from typing import List, Optional, Dict, Any
import numpy as np

from src.core.slicer import SlicedLayer, SliceSettings


# ---------------------------------------------------------------------------
# G-code generator
# ---------------------------------------------------------------------------

class GCodeGenerator:
    """
    Generates G-code from sliced layers.
    """

    def __init__(self):
        self.e_total = 0.0          # total extrusion accumulator
        self.is_retracted = False   # current retraction state
        self.current_x = 0.0
        self.current_y = 0.0
        self.current_z = 0.0
        self.current_f = 0.0       # current feedrate

    # ------------------------------------------------------------------
    # Public API
    # ------------------------------------------------------------------

    def generate(
        self,
        layers: List[SlicedLayer],
        settings: SliceSettings,
        printer_profile: Optional[Dict[str, Any]] = None
    ) -> str:
        """
        Generate complete G-code string for the given layers.

        Args:
            layers: sliced layers from Slicer.slice()
            settings: SliceSettings object
            printer_profile: dict loaded from printers.json

        Returns:
            Complete G-code as a string
        """
        if printer_profile is None:
            printer_profile = _default_printer_profile()

        # Reset state
        self.e_total = 0.0
        self.is_retracted = False
        self.current_x = 0.0
        self.current_y = 0.0
        self.current_z = 0.0
        self.current_f = 0.0

        buf = io.StringIO()
        w = buf.write

        filament_dia = float(printer_profile.get('filament_diameter', settings.filament_diameter))
        nozzle_dia = float(printer_profile.get('nozzle_diameter', settings.nozzle_diameter))

        # --- File header ---
        w("; Generated by Kasynel_Slicer v1.0.0\n")
        w(f"; Layers: {len(layers)}\n")
        w(f"; Layer height: {settings.layer_height} mm\n")
        w(f"; First layer height: {settings.first_layer_height} mm\n")
        w(f"; Infill: {settings.infill_density}% {settings.infill_pattern}\n")
        w(f"; Walls: {settings.wall_count}\n")
        w(f"; Print temp: {settings.print_temp}°C  Bed temp: {settings.bed_temp}°C\n")
        w(f"; Filament diameter: {filament_dia} mm\n")
        w(f"; Nozzle diameter: {nozzle_dia} mm\n")
        w("\n")

        # --- Printer settings ---
        w("G21 ; metric\n")
        w("G90 ; absolute positioning\n")
        w("M82 ; absolute extrusion\n")

        # Heat up (first-layer temp may differ)
        first_temp = getattr(settings, 'print_temp_first_layer', settings.print_temp)
        w(f"M104 S{first_temp} ; set extruder temp (first layer)\n")
        if settings.bed_temp > 0:
            w(f"M140 S{settings.bed_temp} ; set bed temp\n")
        w(f"M109 S{first_temp} ; wait for extruder\n")
        if settings.bed_temp > 0:
            w(f"M190 S{settings.bed_temp} ; wait for bed\n")

        # Start G-code from profile
        start_gcode = printer_profile.get('start_gcode', 'G28\nG92 E0')
        start_gcode = start_gcode.replace('\\n', '\n')
        for line in start_gcode.splitlines():
            w(f"{line}\n")

        w("G92 E0 ; reset extruder\n")

        # Fan: first layer uses fan_first_layer (usually 0)
        fan_first = getattr(settings, 'fan_first_layer', 0)
        if fan_first > 0:
            w(f"M106 S{int(fan_first * 255 / 100)} ; first-layer fan\n")
        else:
            w("M107 ; fan off for first layer\n")

        w("\n")

        # --- Layer loop ---
        fan_kick_layer   = getattr(settings, 'fan_kick_in_layer', 2)
        first_temp       = getattr(settings, 'print_temp_first_layer', settings.print_temp)
        normal_temp      = settings.print_temp
        spiralize        = getattr(settings, 'spiralize_mode', False)
        spiralize_base   = settings.bottom_layers  # base solid layers before spiral

        for i, layer in enumerate(layers):
            is_spiralize_wall = spiralize and (layer.layer_num >= spiralize_base)

            if is_spiralize_wall:
                # Next layer Z for spiral interpolation
                if i + 1 < len(layers):
                    next_z = layers[i + 1].z
                else:
                    next_z = layer.z + settings.layer_height
                is_first_spiral = (layer.layer_num == spiralize_base)
                self._write_spiralize_layer(
                    buf, layer, next_z, settings,
                    filament_dia, nozzle_dia, is_first_spiral
                )
            else:
                self._write_layer(buf, layer, settings, filament_dia, nozzle_dia)

            # Fan kick-in
            if layer.layer_num == fan_kick_layer - 1 and settings.fan_speed > 0:
                fan_pwm = int(round(settings.fan_speed * 255 / 100))
                buf.write(f"M106 S{fan_pwm} ; fan on (layer {layer.layer_num + 1})\n")

            # Switch from first-layer temp to normal temp after layer 0
            if layer.layer_num == 0 and first_temp != normal_temp:
                buf.write(f"M104 S{normal_temp} ; normal print temp\n")

        # --- End G-code ---
        end_gcode = printer_profile.get('end_gcode', 'M104 S0\nM140 S0\nM84')
        end_gcode = end_gcode.replace('\\n', '\n')
        buf.write("\n")
        buf.write("; --- END ---\n")
        for line in end_gcode.splitlines():
            buf.write(f"{line}\n")
        buf.write("M107 ; fan off\n")
        buf.write("; End of file\n")

        return buf.getvalue()

    # ------------------------------------------------------------------
    # Internal: layer writing
    # ------------------------------------------------------------------

    def _write_layer(
        self,
        buf: io.StringIO,
        layer: SlicedLayer,
        settings: SliceSettings,
        filament_dia: float,
        nozzle_dia: float
    ):
        w = buf.write
        is_first = (layer.layer_num == 0)
        lh = settings.first_layer_height if is_first else settings.layer_height

        # Per-feature speeds (fall back to print_speed for old settings)
        fl = settings.first_layer_speed
        outer_spd   = fl if is_first else getattr(settings, 'outer_perimeter_speed', settings.print_speed)
        inner_spd   = fl if is_first else settings.print_speed
        tb_spd      = fl if is_first else getattr(settings, 'top_bottom_speed', settings.print_speed)
        infill_spd  = fl if is_first else settings.infill_speed
        bridge_spd  = fl if is_first else getattr(settings, 'bridge_speed', settings.print_speed)
        retract     = settings.retraction_enabled

        w(f"\n; Layer {layer.layer_num + 1}  Z={layer.z:.4f}  lh={lh:.3f}\n")

        # Move to layer height
        z_feed = int(settings.travel_speed * 60)
        w(f"G1 Z{layer.z:.4f} F{z_feed}\n")
        self.current_z = layer.z

        # Brim (first layer only)
        if layer.brim:
            w("; TYPE:BRIM\n")
            for path in layer.brim:
                self._write_path(buf, path, settings, lh, filament_dia, inner_spd, retract)

        # Perimeters: outer first or inner first depending on setting
        if layer.perimeters:
            w("; TYPE:WALL-OUTER\n")
            perims = layer.perimeters
            # First path = outer wall (slowest), rest = inner
            for idx, path in enumerate(perims):
                spd = outer_spd if idx == 0 else inner_spd
                self._write_path(buf, path, settings, lh, filament_dia, spd, retract)

        # Solid top/bottom
        if layer.top_bottom:
            w("; TYPE:SKIN\n")
            for path in layer.top_bottom:
                self._write_path(buf, path, settings, lh, filament_dia, tb_spd, retract)

        # Sparse infill
        if layer.infill:
            w("; TYPE:FILL\n")
            for path in layer.infill:
                self._write_path(buf, path, settings, lh, filament_dia, infill_spd, retract)

        # Support
        if layer.support:
            w("; TYPE:SUPPORT\n")
            for path in layer.support:
                self._write_path(buf, path, settings, lh, filament_dia, infill_spd, retract)

    # ------------------------------------------------------------------
    # Internal: spiralize (non-stop / vase mode) layer writing
    # ------------------------------------------------------------------

    def _write_spiralize_layer(
        self,
        buf: io.StringIO,
        layer,
        next_z: float,
        settings: SliceSettings,
        filament_dia: float,
        nozzle_dia: float,
        is_first_spiral: bool
    ):
        """
        スパイラル（ノンストップ/バース）モードのレイヤー出力。
        外周1本のみを使い、Z を XY 移動と同時に線形補間しながら増加させる。
        リトラクションなし、Z 単独移動なし。
        """
        w = buf.write
        lh = settings.layer_height
        feed_travel = int(settings.travel_speed * 60)
        feed_print  = int(
            getattr(settings, 'outer_perimeter_speed', settings.print_speed) * 60
        )

        w(f"\n; Layer {layer.layer_num + 1}  Z={layer.z:.4f} → {next_z:.4f}  [SPIRALIZE]\n")

        # 最初のスパイラル層だけ Z 位置をセット
        # (それ以降は前の層の連続スパイラルで Z がすでに正しい高さにある)
        if is_first_spiral:
            w(f"G1 Z{layer.z:.4f} F{feed_travel}\n")
            self.current_z = layer.z

        if not layer.perimeters:
            return

        # 外周パスのみ使用
        outer = np.array(layer.perimeters[0], dtype=np.float64)
        if outer.ndim != 2 or outer.shape[1] < 2 or len(outer) < 2:
            return

        # ループが閉じていなければ閉じる
        if not np.allclose(outer[0], outer[-1], atol=1e-4):
            outer = np.vstack([outer, outer[0]])

        # 各セグメントの長さを計算
        diffs    = np.diff(outer[:, :2], axis=0)
        seg_lens = np.hypot(diffs[:, 0], diffs[:, 1])
        total_len = float(np.sum(seg_lens))
        if total_len < 1e-6:
            return

        # スパイラル Z 範囲
        z_start = layer.z
        dz      = next_z - z_start

        # スタート地点へ XY トラベル（リトラクションなし）
        start_x = float(outer[0, 0])
        start_y = float(outer[0, 1])
        travel_dist = math.hypot(start_x - self.current_x, start_y - self.current_y)
        if travel_dist > 1e-3:
            w(f"G1 X{start_x:.4f} Y{start_y:.4f} F{feed_travel}\n")
            self.current_x = start_x
            self.current_y = start_y

        # 印刷フィードレート設定
        if feed_print != self.current_f:
            w(f"G1 F{feed_print}\n")
            self.current_f = feed_print

        # スパイラル押出し: 各点で Z を線形補間しながら同時に移動
        cum_len = 0.0
        for i, seg_len in enumerate(seg_lens):
            if seg_len < 1e-6:
                continue
            cum_len += seg_len
            x2 = float(outer[i + 1, 0])
            y2 = float(outer[i + 1, 1])

            t     = cum_len / total_len
            z_now = z_start + dz * t

            e_inc = self._calc_extrusion(seg_len, settings.line_width, lh, filament_dia)
            self.e_total += e_inc

            w(f"G1 X{x2:.4f} Y{y2:.4f} Z{z_now:.4f} E{self.e_total:.5f}\n")
            self.current_x = x2
            self.current_y = y2
            self.current_z = z_now

    # ------------------------------------------------------------------
    # Internal: path writing
    # ------------------------------------------------------------------

    def _write_path(
        self,
        buf: io.StringIO,
        path: np.ndarray,
        settings: SliceSettings,
        layer_height: float,
        filament_dia: float,
        speed: float,
        retract: bool = True
    ):
        """Write G-code for a single path (N, 2) array of XY points."""
        if path is None or len(path) < 2:
            return

        path = np.array(path, dtype=np.float64)
        if path.ndim != 2 or path.shape[1] < 2:
            return

        w = buf.write
        feed_print = int(speed * 60)  # mm/min
        feed_travel = int(settings.travel_speed * 60)

        start_x, start_y = float(path[0, 0]), float(path[0, 1])

        # Travel to start of path
        self._travel_to(buf, start_x, start_y, settings, retract)

        # De-retract if needed
        if self.is_retracted and retract:
            self._deretract(buf, settings)

        # Update feed if changed
        if feed_print != self.current_f:
            w(f"G1 F{feed_print}\n")
            self.current_f = feed_print

        # Extrude along path
        for i in range(1, len(path)):
            x1, y1 = float(path[i - 1, 0]), float(path[i - 1, 1])
            x2, y2 = float(path[i, 0]), float(path[i, 1])

            dist = math.hypot(x2 - x1, y2 - y1)
            if dist < 1e-6:
                continue

            e_inc = self._calc_extrusion(
                dist, settings.line_width, layer_height, filament_dia
            )
            self.e_total += e_inc

            w(f"G1 X{x2:.4f} Y{y2:.4f} E{self.e_total:.5f}\n")
            self.current_x = x2
            self.current_y = y2

    def _travel_to(
        self,
        buf: io.StringIO,
        x: float,
        y: float,
        settings: SliceSettings,
        retract: bool = True
    ):
        """Move to (x, y) without extruding, with optional retraction + z-hop."""
        dist = math.hypot(x - self.current_x, y - self.current_y)
        min_dist = getattr(settings, 'retraction_min_distance', 1.5)
        if dist < min_dist:
            # Short travel: just move, no retract
            buf.write(f"G1 X{x:.4f} Y{y:.4f} F{int(settings.travel_speed * 60)}\n")
            self.current_x = x
            self.current_y = y
            return

        w = buf.write
        feed_travel = int(settings.travel_speed * 60)
        z_hop = getattr(settings, 'retraction_z_hop', 0.0)

        if retract and not self.is_retracted:
            self._retract(buf, settings)
            # Z-hop after retraction
            if z_hop > 0:
                w(f"G1 Z{self.current_z + z_hop:.4f} F{feed_travel}\n")

        w(f"G1 X{x:.4f} Y{y:.4f} F{feed_travel}\n")

        # Z-hop down before print
        if retract and z_hop > 0 and self.is_retracted:
            w(f"G1 Z{self.current_z:.4f} F{feed_travel}\n")

        self.current_x = x
        self.current_y = y
        self.current_f = feed_travel

    def _retract(self, buf: io.StringIO, settings: SliceSettings):
        """Write retraction G-code."""
        feed_r = int(settings.retraction_speed * 60)
        self.e_total -= settings.retraction_distance
        buf.write(f"G1 E{self.e_total:.5f} F{feed_r} ; retract\n")
        self.is_retracted = True

    def _deretract(self, buf: io.StringIO, settings: SliceSettings):
        """Write de-retraction G-code (+ extra prime if set)."""
        feed_r = int(settings.retraction_speed * 60)
        extra = getattr(settings, 'retraction_extra_prime', 0.0)
        self.e_total += settings.retraction_distance + extra
        buf.write(f"G1 E{self.e_total:.5f} F{feed_r} ; deretract\n")
        self.is_retracted = False

    # ------------------------------------------------------------------
    # Extrusion calculation
    # ------------------------------------------------------------------

    @staticmethod
    def _calc_extrusion(
        distance: float,
        line_width: float,
        layer_height: float,
        filament_diameter: float
    ) -> float:
        """
        Calculate extrusion amount in mm of filament for a move.

        Formula: E = distance * line_width * layer_height / (pi * (filament_dia/2)^2)
        """
        filament_r = filament_diameter / 2.0
        filament_area = math.pi * filament_r ** 2
        extrusion_volume = distance * line_width * layer_height
        return extrusion_volume / filament_area


# ---------------------------------------------------------------------------
# Default profile
# ---------------------------------------------------------------------------

def _default_printer_profile() -> Dict[str, Any]:
    return {
        'bed_size': [220, 220],
        'nozzle_diameter': 0.4,
        'filament_diameter': 1.75,
        'start_gcode': 'G28\nG92 E0',
        'end_gcode': 'M104 S0\nM140 S0\nG28 X0\nM84',
    }


def load_printer_profiles(profiles_path: str) -> Dict[str, Any]:
    """Load printer profiles from JSON file."""
    import json
    try:
        with open(profiles_path, 'r') as f:
            return json.load(f)
    except Exception as e:
        print(f"[GCode] Failed to load printer profiles: {e}")
        return {'Generic Printer': _default_printer_profile()}


def load_material_profiles(profiles_path: str) -> Dict[str, Any]:
    """Load material profiles from JSON file."""
    import json
    try:
        with open(profiles_path, 'r') as f:
            return json.load(f)
    except Exception as e:
        print(f"[GCode] Failed to load material profiles: {e}")
        return {
            'PLA': {'print_temp': 210, 'bed_temp': 60, 'fan_speed': 100, 'retraction': 5.0}
        }
